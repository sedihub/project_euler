/*
PROBLEM:
  Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate 
  (polygonal) numbers and are generated by the following formulae:

      Triangle    P_{3,n} = n(n+1)/2   1, 3, 6, 10, 15, ...
      Square      P_{4,n} = n^2        1, 4, 9, 16, 25, ...
      Pentagonal  P_{5,n} = n(3n−1)/2  1, 5, 12, 22, 35, ...
      Hexagonal   P_{6,n} = n(2n−1)    1, 6, 15, 28, 45, ...
      Heptagonal  P_{7,n} = n(5n−3)/2  1, 7, 18, 34, 55, ...
      Octagonal   P_{8,n} = n(3n−2)    1, 8, 21, 40, 65, ...

  The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

    1. The set is cyclic, in that the last two digits of each number is the first two digits
       of the next number (including the last number with the first). 
    2. Each polygonal type: triangle (P_{3,127}=8128), square (P_{4,91}=8281), and pentagonal 
       (P_{5,44}=2882), is represented by a different number in the set. 
    3. This is the only set of 4-digit numbers with this property.

  Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal 
  type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a 
  different number in the set.


SOLUTION:
  Depth-first search. Compile separate maps of first two digits to vector of last two digits. Then
  perform a depth-first search from smallest to the largest.

  Note that the last two digit cannot be 0X.

  ANSWER: 28710
          [2] 28-82
          [3] 81-28
          [5] 12-81
          [4] 25-12
          [1] 56-25
          [0] 82-56
          Sum: 28710
          Order: 0 2 3 5 4 1 
  0 <-> Triangular, 1 <-> square, etc.
**/

#include <iostream>
#include <map>
#include <set>
#include <iterator>
#include <vector>


typedef unsigned int uint;


inline uint triangle(uint n) {
  return (n * (n + 1)) / 2;
}


inline uint square(uint n) {
  return n * n;
}


inline uint pentagonal(uint n) {
  return (n * (3 * n - 1)) / 2;
}


inline uint hexagonal(uint n) {
  return n * (2 * n - 1);
}


inline uint heptagonal(uint n) {
  return ( n * (5 * n - 3)) / 2;
}


inline uint octagonal(uint n) {
  return n * (3 * n - 2);
}

inline uint polygonal_number(uint polygonal_num_idx, uint n) {
  switch(polygonal_num_idx) {
    case 0:  
      return triangle(n);
    case 1:  
      return square(n);
    case 2:  
      return pentagonal(n);
    case 3:  
      return hexagonal(n);
    case 4:  
      return heptagonal(n);
    case 5:  
      return octagonal(n);
  }
  return 0;
}

inline bool is_four_digit(uint n) {
  return n >= 1000 && n <= 9999;
}

inline bool is_two_digit(uint n) {
  return n >= 10 && n <= 99;
}


template <typename T> 
void print_vector(const std::vector<T> &vec)
{
  typename std::vector<T>::const_iterator it;
  for (it = vec.begin(); it != vec.end(); it++) 
    std::cout << *it << " ";
  std::cout << std::endl;
}


void generate_permutations(
  const uint &start, 
  const uint &stop, 
  std::vector< std::vector<uint> > &permutations)
{
  if (permutations[0].size() == (stop - start + 1)) {
    return;
  }

  std::vector< std::vector<uint> > this_round;
  std::vector< std::vector<uint> > new_permutations;
  std::vector< std::vector<uint> >::iterator it;
  for (uint n = start; n <= stop; n++) {
    if (std::find(permutations[0].begin(), permutations[0].end(), n) != permutations[0].end()) {
      continue;
    }
    this_round.clear();
    for (it = permutations.begin(); it != permutations.end(); it++) {
      this_round.push_back(*it);
      this_round.back().push_back(n);
    }
    generate_permutations(start, stop, this_round);
    new_permutations.insert(new_permutations.end(), this_round.begin(), this_round.end());
  }
  permutations = new_permutations;
}


bool find_unique_cycle(
  std::vector<uint> order,
  const uint &first_two_digits,
  const uint &last_two_digits,
  uint &sum,
  std::map<uint, std::map<uint, std::set<uint> > > &polygonals
) 
{
  if (order.size() == 0) {
    if (first_two_digits == last_two_digits) {
      sum += 100 * first_two_digits + last_two_digits;
      return true;
    }
    else {
      return false;
    }
  }
  //
  uint n = order.back();
  order.pop_back();
  if (polygonals[n].find(first_two_digits) == polygonals[n].end()) {
    return false;
  }
  else {
    std::set<uint>::iterator it;
    for (it = polygonals[n][first_two_digits].begin(); it != polygonals[n][first_two_digits].end(); it++) {
      if (find_unique_cycle(order, *it, last_two_digits, sum, polygonals)) {
        std::cout << "[" << n << "] " << first_two_digits << "-" << *it << std::endl;
        sum += 100 * first_two_digits + *it;
        return true;
      }
    }
  }
  return false;
}


int main()
{
  std::map<uint, std::map<uint, std::set<uint> > > polygonal_numbers;
  polygonal_numbers[0] = std::map<uint, std::set<uint> >();  // Triangulars
  polygonal_numbers[1] = std::map<uint, std::set<uint> >();  // Squares
  polygonal_numbers[2] = std::map<uint, std::set<uint> >();  // Pentagonals
  polygonal_numbers[3] = std::map<uint, std::set<uint> >();  // Hexagonals
  polygonal_numbers[4] = std::map<uint, std::set<uint> >();  // Heptagonals
  polygonal_numbers[5] = std::map<uint, std::set<uint> >();  // Octagonals

  uint n = 19;  
  uint figurate_number;
  uint first_two_digits, last_two_digits;
  bool found_four_digit_figurate_number = true;
  while (found_four_digit_figurate_number) {
    found_four_digit_figurate_number = false;
    //
    for (uint num_idx = 0; num_idx < 6; num_idx++) {
      figurate_number = polygonal_number(num_idx, n);
      first_two_digits = figurate_number / 100;
      last_two_digits = figurate_number % 100;
      if (is_four_digit(figurate_number)) {
        found_four_digit_figurate_number = true;
        if (polygonal_numbers[num_idx].find(first_two_digits) == polygonal_numbers[num_idx].end()) {
          polygonal_numbers[num_idx][first_two_digits] = std::set<uint>{last_two_digits};
        }
        else {
          polygonal_numbers[num_idx][first_two_digits].insert(last_two_digits);
        }
      }
    }
    //
    n++;
  }


  // Depth-first search:
  //  - First, we generate different permutations of 1 to 5.
  //  - Then we use these permutations to search polygonal groups in various orders.
  //  - The reason for only considering permutations of 1-5 as oppsed to 0 to 5 is that we start from 0. 
  std::vector< std::vector<uint> > perms = {{}};
  std::vector< std::vector<uint> >::iterator it;
  generate_permutations(1, 5, perms);
  // std::cout << "Size: " << perms.size() << std::endl;
  
  // Search for the cycle:
  std::map<uint, std::set<uint> >::iterator mit;
  std::set<uint>::iterator sit;
  std::vector<uint> order;
  uint sum = 0;
  for (mit = polygonal_numbers[0].begin(); mit != polygonal_numbers[0].end(); mit++) {
    for (sit = mit->second.begin(); sit != mit->second.end(); sit++) {
      for (it = perms.begin(); it != perms.end(); it++) {
        //print_vector<uint>(*it);
        if (find_unique_cycle(*it, *sit, mit->first, sum, polygonal_numbers)) {
          std::cout << "[0] " << mit->first << "-" << *sit << std::endl;
          std::cout << "Sum: " << sum << std::endl;
          std::cout << "Order: " << 0 << " "; 
          print_vector<uint>(*it);
          goto FOUND;
        }
      }
    }
  }
  FOUND:;

  return 0;
}
