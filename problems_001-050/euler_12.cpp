/*
PROBLEM:
    The sequence of triangle numbers is generated by adding the natural numbers.
    What is the value of the first triangle number to have over five hundred divisors?

SOLUTION:
    Since the nth triangle number is the sum of all natural numbers not greater than n,
    it is given by: 

        t_n = n * (n + 1)/2

    If we decompose t_n into its prime factors, we can compute the number of its divisors
    using:

            t_nn = p_0 ^ m_0 * p_1 ^ m_1 + ... + p_k ^ m_k
            num_divisors(t_n) = (m_0 + 1) * (m_1 + 1) * ... * (m_k + 1)

    Thus, the problem reduces to finding the decomposition of a number into its prime 
    divisors.

    Actually, this can be done more efficiently by finding the prime factors of n instead 
    of t_n.

    The solution is: t_{12375}=76576500 has 576 divisors!
**/

#include <iostream>
#include <map>
#include <set>


template <typename T>
class PrimalityTest
{
public:
    PrimalityTest(){
        primes.insert(2);
        primes.insert(3);
        primes.insert(5);
    }

    bool is_prime(T n)
    {
        if(n == 1)
            return false;
        if (primes.find(n) != primes.end())
            return true;
        for (it = primes.begin(); it != primes.end(); ++it){
            if (n % (*it) == 0) {
                return false;
            }
            if ((*it) * (*it) > n) {
                primes.insert(n);
                return true;
            }
        }
        //
        // If this number is beyond the range of current primes, get the rest:
        rit = primes.rbegin();
        std::advance(rit, 1);
        T m = (*rit);
        while (m <= n) {
            m++;
            this->is_prime(m);
            if (n % m == 0) {
                return false;
            }
        }
        primes.insert(n);
        return true;
    }

    void print_primes(){
        for (it = primes.begin(); it != primes.end(); ++it) {
            std::cout << "\t" << *it << std::endl;
        }
    }


    const std::set<T>& get_primes() const
    {
        return primes;
    }


    int get_number_of_primes(){
        return primes.size();
    }

protected:
    std::set<T> primes;
    typename std::set<T>::iterator it;
    typename std::set<T>::reverse_iterator rit;
};


template <typename T> 
T triangle_number(T n)
{ 
    return n * (n + 1) / 2; 
}


template <typename T>
std::map<T, T> prime_decomposition(T n, PrimalityTest<T> *prime_test)
{
    std::map<T, T> decomp;

    prime_test->is_prime(n);
    const std::set<T>&  primes = prime_test-> get_primes();
    typename std::set<T>::const_iterator it;
    for (it = primes.begin(); it != primes.end(); ++it){
        if (n % *it != 0) 
            continue;
        decomp[*it] = 0;
        while (n % *it == 0){
            decomp[*it] += 1;
            n /= *it;
        }
    }

    return decomp;
}


template <class T>
std::map<T, T> merge_prime_decompositions(
    std::map<T, T> &decomp_1, 
    std::map<T, T> &decomp_2
)
{
    std::map<T, T> combination = decomp_1;
    typename std::map<T, T>::iterator it;
    for (it = decomp_2.begin(); it != decomp_2.end(); ++it) {
        if (combination.find(it->first) == combination.end()) {
            combination[it->first] = it->second;
        }
        else {
            combination[it->first] += it->second;
        }
    }

    return combination;
}


template <class T> 
T compute_number_of_divisors(std::map<T, T> &prime_decomp)
{
    T num_divisors = 1;
    typename std::map<T, T>::iterator it;
    for (it = prime_decomp.begin(); it != prime_decomp.end(); ++it) {
        num_divisors *= (1 + it->second);
    }

    return num_divisors;
}


int main()
{
    typedef unsigned long long int ulli;

    const ulli num_divisors = 500;
    ulli n = 2;
    ulli n_mod_6;

    PrimalityTest<ulli> prime_test;

    std::map<ulli, ulli> n_decom = prime_decomposition<ulli>(n, &prime_test);
    std::map<ulli, ulli> np1_decom = prime_decomposition<ulli>((n + 1), &prime_test);
    std::map<ulli, ulli> prime_decomp_nxnp1 = merge_prime_decompositions<ulli>(
        n_decom, np1_decom);
    prime_decomp_nxnp1[2] -= 1;
    ulli tn_num_divisors = compute_number_of_divisors<ulli>(prime_decomp_nxnp1);
    while (tn_num_divisors <= num_divisors)
    { 
        n++; 
        n_decom = np1_decom;
        np1_decom = prime_decomposition<ulli>((n + 1), &prime_test); 
        prime_decomp_nxnp1 = merge_prime_decompositions<ulli>(
            n_decom, np1_decom);
        prime_decomp_nxnp1[2] -= 1;
        tn_num_divisors = compute_number_of_divisors<ulli>(prime_decomp_nxnp1);
        // // Uncomment these lines if you want to see what is happening:
        // std::cout << triangle_number<ulli>(n) << " ---> " << tn_num_divisors << "\t{ ";
        // for (std::map<ulli, ulli>::iterator it = prime_decomp_nxnp1.begin(); it != prime_decomp_nxnp1.end(); ++it){
        //     std::cout << it->first << "^" << it->second << ", ";
        // }
        // std::cout << "}" << std::endl;
    }

    std::cout << "t_{" << n << "} = " << triangle_number<ulli>(n) << " has "\
              << tn_num_divisors << " divisors!" << std::endl;

    return 0;
}
