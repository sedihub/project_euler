/*
PROBLEM:
  Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

        Triangle    Tn=n(n+1)/2   1, 3, 6, 10, 15, ...
        Pentagonal    Pn=n(3n−1)/2    1, 5, 12, 22, 35, ...
        Hexagonal   Hn=n(2n−1)    1, 6, 15, 28, 45, ...

  It can be verified that T285 = P165 = H143 = 40755.

  Find the next triangle number that is also pentagonal and hexagonal.


SOLUTION:
  We could attempt a brute-force search, but it will not be efficient as most of the numbers
  encountered will be neither triangular, nor pentagonal nor hexagonal. 

  The easiest way to limit the search space is to identify triangular numbers and then check
  if the number is pentagonal and hexagonal.

  ANSWER: 1533776805 corresponding to T_55385
**/

#include "iostream"
#include "math.h"


typedef unsigned long int ulint;


ulint triangular_number(ulint n)
{
  n *= n + 1;
  n /= 2;
  return n;
}


bool is_triangular_number(ulint n)
{
    double d = (-1.0 + sqrt(1.0 + 8.0 * (double)n)) / 2.0;
    if (d == floor(d)) 
      return true;
    else
      return false;
}


bool is_pentagonal_number(ulint n)
{
    double d = (1.0 + sqrt(1.0 + 24.0 * (double)n)) / 6.0;
    if (d == floor(d))
      return true;
    else
      return false;
}


bool is_hexagonal_number(ulint n)
{
  double d = (1.0 + sqrt(1.0 + 8.0 * (double)n)) / 4.0;
  if (d == floor(d))
    return true;
  else
    return false;
}


int main()
{
  // Test functions:
  // std::cout << is_triangular_number(40755) << std::endl;
  // std::cout << is_pentagonal_number(40755) << std::endl;
  // std::cout << is_hexagonal_number(40755)  << std::endl;
  
  ulint n = 285;
  ulint t_n;
  while (true) {
    n++;
    t_n = triangular_number(n);
    if(is_pentagonal_number(t_n) && is_hexagonal_number(t_n))
       break;
  }

  std::cout << "\tT_" << n <<  " = " << t_n << std::endl;
  
  return 0;      
}
